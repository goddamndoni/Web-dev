import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, EventEmitter, Input, Output, ViewChild, ViewChildren, HostBinding, Directive, Pipe, ElementRef, HostListener } from '@angular/core';
import { trigger, transition, animate, style } from '@angular/animations';
import * as i1$1 from '@angular/platform-browser';

const defaultAria = {
    galleryLabel: 'Image Gallery',
    viewerLabel: 'Displayed gallery images.',
};

const isBrowser = typeof window !== 'undefined';
const SUPPORT = {
    scrollBehavior: isBrowser && 'scrollBehavior' in document.body.style,
};
const UA = {
    ios: isBrowser && !!window.navigator.userAgent.match(/iP(ad|hone|od)/),
};

const orientations = {
    left: 2 /* OrientationFlag.LEFT */,
    right: 4 /* OrientationFlag.RIGHT */,
    top: 8 /* OrientationFlag.TOP */,
    bottom: 16 /* OrientationFlag.BOTTOM */,
};

class ChevronIconComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: ChevronIconComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.8", type: ChevronIconComponent, isStandalone: true, selector: "chevron-icon", ngImport: i0, template: "<!-- Icon made by Dave Gandy from www.flaticon.com -->\n<svg\n  version=\"1.1\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  x=\"0px\"\n  y=\"0px\"\n  viewBox=\"0 0 407.436 407.436\"\n  xml:space=\"preserve\"\n>\n  <polygon\n    points=\"112.814,0 91.566,21.178 273.512,203.718 91.566,386.258 112.814,407.436 315.869,203.718 \"\n  />\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n</svg>\n", styles: ["svg{width:26px;height:26px}svg{fill:#fff;filter:drop-shadow(0 0 1px black);display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: ChevronIconComponent, decorators: [{
            type: Component,
            args: [{ selector: 'chevron-icon', changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, template: "<!-- Icon made by Dave Gandy from www.flaticon.com -->\n<svg\n  version=\"1.1\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  x=\"0px\"\n  y=\"0px\"\n  viewBox=\"0 0 407.436 407.436\"\n  xml:space=\"preserve\"\n>\n  <polygon\n    points=\"112.814,0 91.566,21.178 273.512,203.718 91.566,386.258 112.814,407.436 315.869,203.718 \"\n  />\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n  <g></g>\n</svg>\n", styles: ["svg{width:26px;height:26px}svg{fill:#fff;filter:drop-shadow(0 0 1px black);display:block}\n"] }]
        }] });

class ThumbsComponent {
    get cssClass() {
        return `thumbs--${this.orientation}`;
    }
    get hostOffsetAxis() {
        return this.vertical
            ? this.elRef.nativeElement.offsetHeight
            : this.elRef.nativeElement.offsetWidth;
    }
    get scrollKey() {
        return this.vertical ? 'scrollTop' : 'scrollLeft';
    }
    get thumbsEmpty() {
        return !this.thumbsRef || !this.thumbsRef.length;
    }
    get vertical() {
        return this.orientation === 'left' || this.orientation === 'right';
    }
    constructor(cd, elRef) {
        this.cd = cd;
        this.elRef = elRef;
        this.items = [];
        this.thumbClick = new EventEmitter();
        this.thumbHover = new EventEmitter();
        this.showStartArrow = false;
        this.showEndArrow = false;
        this.onArrowsObserved = entries => {
            if (this.thumbsEmpty)
                return;
            const firstTarget = entries[0].target;
            const { first, last } = this.thumbsRef;
            const firstThumbEntry = firstTarget === first.nativeElement ? entries[0] : entries[1];
            const lastThumbEntry = firstTarget === last.nativeElement ? entries[0] : entries[1];
            this.setObservedArrows(firstThumbEntry, lastThumbEntry);
            this.cd.detectChanges();
        };
    }
    ngOnChanges({ arrows, items }) {
        if (arrows) {
            if (arrows.currentValue) {
                this.observeArrows();
            }
            else if (!arrows.currentValue) {
                this.showStartArrow = this.showEndArrow = false;
                this.unobserveArrows();
            }
        }
        if (items) {
            setTimeout(() => {
                if (this.arrows) {
                    this.observeArrows();
                }
                this.centerThumbIfNeeded(this.selectedIndex);
            });
        }
    }
    ngOnDestroy() {
        this.unobserveArrows();
    }
    slide(direction) {
        let delta;
        if (this.arrowSlideByLength) {
            delta = this.arrowSlideByLength;
        }
        else {
            // Note: Slide by the full height/width of the gallery
            // or by the overflow of the thumbs - to prevent unnecessary requestAnimationFrame calls while trying to scroll
            // outside of the min/max scroll of the thumbs
            const thumbList = this.thumbListRef.nativeElement;
            const thumbListScrollAxis = this.vertical
                ? thumbList.scrollHeight
                : thumbList.scrollWidth;
            const thumbListOffsetAxis = this.vertical
                ? thumbList.offsetHeight
                : thumbList.offsetWidth;
            delta = Math.min(thumbListOffsetAxis, thumbListScrollAxis - thumbListOffsetAxis);
        }
        this.scroll(delta * direction);
    }
    centerThumbIfNeeded(index) {
        if (!this.items || this.items.length <= 1) {
            return;
        }
        const nextItemRef = this.thumbsRef.toArray()[index];
        if (!nextItemRef) {
            return;
        }
        const nextItemEl = nextItemRef.nativeElement;
        const { offsetLeft, offsetTop, offsetWidth, offsetHeight } = nextItemEl;
        const itemOffset = this.vertical ? offsetTop : offsetLeft;
        const itemOffsetAxis = this.vertical ? offsetHeight : offsetWidth;
        const hostScrollAxis = this.hostOffsetAxis;
        const thumbListScroll = this.thumbListRef.nativeElement[this.scrollKey];
        const nextScrollDelta = itemOffset + itemOffsetAxis / 2 - hostScrollAxis / 2 - thumbListScroll;
        if (thumbListScroll + hostScrollAxis < itemOffset + itemOffsetAxis ||
            thumbListScroll > itemOffset) {
            this.scroll(nextScrollDelta);
        }
    }
    select(index) {
        this.selectedIndex = index;
        this.cd.detectChanges();
        if (this.autoScroll) {
            setTimeout(() => this.centerThumbIfNeeded(index));
        }
    }
    emitEvent(index, item, event, emitter) {
        emitter.emit({
            index,
            item,
            event,
        });
    }
    onLoadChange(item, success) {
        item._thumbFailed = !success;
    }
    scroll(totalScrollDelta) {
        if (!isBrowser) {
            return;
        }
        if (SUPPORT.scrollBehavior || this.scrollBehavior === 'auto') {
            this.shiftByDelta(totalScrollDelta);
            return;
        }
        if (this.scrollId != null) {
            cancelAnimationFrame(this.scrollId);
        }
        const totalDistance = Math.abs(totalScrollDelta);
        const startTime = Date.now();
        const baseArrowSlideTime = 200;
        let totalTime = (Math.log10(totalDistance) - 1.1) * baseArrowSlideTime;
        if (totalTime < 0) {
            totalTime = baseArrowSlideTime;
        }
        let currentScroll = 0;
        // Emulating native scroll-behavior: smooth
        // NOTE: This function is called on per frame basis recursively to create smooth animation.
        // The scroll value is updated proportionally to the time elapsed since the animation's start.
        // The period of requested frames should match the display's refresh rate as recommended in W3C spec.
        const animate = () => {
            const suggestedScroll = Math.ceil(((Date.now() - startTime) / totalTime) * totalDistance);
            let frameScroll = Math.min(suggestedScroll - currentScroll, totalDistance - currentScroll);
            frameScroll *= Math.sign(totalScrollDelta);
            currentScroll = suggestedScroll;
            this.shiftByDelta(frameScroll);
            if (currentScroll <= totalDistance) {
                this.scrollId = requestAnimationFrame(animate);
            }
        };
        this.scrollId = requestAnimationFrame(animate);
    }
    shiftByDelta(delta) {
        this.thumbListRef.nativeElement[this.scrollKey] += delta;
    }
    observeArrows() {
        if (this.thumbsEmpty)
            return;
        if (!this.arrowObserver) {
            this.arrowObserver = new IntersectionObserver(this.onArrowsObserved, {
                root: this.thumbListRef.nativeElement,
                threshold: 1.0,
            });
        }
        else {
            this.unobserveArrows();
        }
        this.arrowObserver.observe(this.thumbsRef.first.nativeElement);
        this.arrowObserver.observe(this.thumbsRef.last.nativeElement);
    }
    setObservedArrows(firstThumb, lastThumb) {
        const inverse = this.isRtl && !this.vertical;
        if (inverse) {
            if (lastThumb)
                this.showStartArrow = lastThumb.intersectionRatio < 1;
            if (firstThumb)
                this.showEndArrow = firstThumb.intersectionRatio < 1;
        }
        else {
            if (firstThumb)
                this.showStartArrow = firstThumb.intersectionRatio < 1;
            if (lastThumb)
                this.showEndArrow = lastThumb.intersectionRatio < 1;
        }
    }
    unobserveArrows() {
        this.arrowObserver && this.arrowObserver.disconnect();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: ThumbsComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.8", type: ThumbsComponent, isStandalone: true, selector: "thumbs", inputs: { items: "items", selectedIndex: "selectedIndex", aria: "aria", orientation: "orientation", arrows: "arrows", arrowSlideByLength: "arrowSlideByLength", autoScroll: "autoScroll", thumbTemplate: "thumbTemplate", arrowTemplate: "arrowTemplate", errorTemplate: "errorTemplate", scrollBehavior: "scrollBehavior", isRtl: "isRtl" }, outputs: { thumbClick: "thumbClick", thumbHover: "thumbHover" }, host: { properties: { "class": "this.cssClass" } }, viewQueries: [{ propertyName: "thumbListRef", first: true, predicate: ["thumbs"], descendants: true, static: true }, { propertyName: "thumbsRef", predicate: ["thumb"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<button\n  *ngIf=\"showStartArrow\"\n  aria-label=\"Previous thumbnails\"\n  class=\"thumbs-arrow thumbs-arrow-prev\"\n  (click)=\"slide(-1)\"\n>\n  <div *ngIf=\"!arrowTemplate; else $any(arrowTemplate)\">\n    <chevron-icon></chevron-icon>\n  </div>\n</button>\n\n<ul #thumbs [style.scrollBehavior]=\"scrollBehavior\" [class.rtl]=\"isRtl\">\n  <li *ngIf=\"!items || !items.length\" class=\"thumbs-initial-item\"></li>\n  <li\n    #thumb\n    *ngFor=\"let item of items; let i = index\"\n    [class.thumbs-item--selected]=\"i === selectedIndex\"\n    aria-hidden=\"true\"\n    (click)=\"emitEvent(i, item, $event, thumbClick)\"\n    (mouseenter)=\"emitEvent(i, item, $event, thumbHover)\"\n  >\n    <ng-container *ngIf=\"!thumbTemplate; else customThumbTemplate\">\n      <img\n        [src]=\"item.thumbSrc || ''\"\n        [alt]=\"item.alt\"\n        (load)=\"onLoadChange(item, true)\"\n        (error)=\"onLoadChange(item, false)\"\n      />\n\n      <ng-container *ngIf=\"item._thumbFailed\">\n        <div\n          *ngIf=\"!errorTemplate; else $any(errorTemplate)\"\n          class=\"thumbs-error\"\n        >\n          <div\n            class=\"thumbs-error-icon\"\n            [class.thumbs-error-icon--video]=\"item.video\"\n          ></div>\n        </div>\n      </ng-container>\n    </ng-container>\n\n    <ng-template #customThumbTemplate>\n      <ng-container\n        *ngTemplateOutlet=\"\n          $any(thumbTemplate);\n          context: { index: i, selectedIndex: selectedIndex, item: item }\n        \"\n      ></ng-container>\n    </ng-template>\n  </li>\n</ul>\n\n<button\n  *ngIf=\"showEndArrow\"\n  aria-label=\"Next thumbnails\"\n  class=\"thumbs-arrow thumbs-arrow-next\"\n  (click)=\"slide(1)\"\n>\n  <div *ngIf=\"!arrowTemplate; else $any(arrowTemplate)\">\n    <chevron-icon></chevron-icon>\n  </div>\n</button>\n", styles: [":host{flex:1 0 auto;position:relative;background-color:#f3f3f3}:host.thumbs--top,:host.thumbs--bottom{width:100%}:host.thumbs--top ul,:host.thumbs--bottom ul{width:100%;display:flex;overflow-x:scroll;overflow-y:hidden}:host.thumbs--top ul.rtl li:first-child,:host.thumbs--bottom ul.rtl li:first-child{margin-left:0;margin-right:auto}:host.thumbs--top ul.rtl li:last-child,:host.thumbs--bottom ul.rtl li:last-child{margin-right:0;margin-left:auto}:host.thumbs--top li,:host.thumbs--bottom li{flex:none}:host.thumbs--top li:not(:first-child),:host.thumbs--bottom li:not(:first-child){border-left:0}:host.thumbs--top li:first-child,:host.thumbs--bottom li:first-child{margin-left:auto}:host.thumbs--top li:last-child,:host.thumbs--bottom li:last-child{margin-right:auto}:host.thumbs--top .thumbs-arrow,:host.thumbs--bottom .thumbs-arrow{top:0;height:100%}:host.thumbs--top .thumbs-arrow>div,:host.thumbs--bottom .thumbs-arrow>div{width:30px;height:100%}:host.thumbs--top .thumbs-arrow-prev,:host.thumbs--bottom .thumbs-arrow-prev{left:0}:host.thumbs--top .thumbs-arrow-next,:host.thumbs--bottom .thumbs-arrow-next{right:0}:host.thumbs--top .thumbs-error,:host.thumbs--bottom .thumbs-error{border-right:1px solid #cecece}:host.thumbs--left,:host.thumbs--right{height:100%}:host.thumbs--left ul,:host.thumbs--right ul{height:100%;overflow-y:scroll;overflow-x:hidden}:host.thumbs--left li,:host.thumbs--right li{border-top:0}:host.thumbs--left .thumbs-arrow,:host.thumbs--right .thumbs-arrow{width:100%}:host.thumbs--left .thumbs-arrow>div,:host.thumbs--right .thumbs-arrow>div{width:100%;height:30px}:host.thumbs--left .thumbs-arrow chevron-icon,:host.thumbs--right .thumbs-arrow chevron-icon{transform:rotate(90deg)}:host.thumbs--left .thumbs-arrow-prev,:host.thumbs--right .thumbs-arrow-prev{top:0}:host.thumbs--left .thumbs-arrow-next,:host.thumbs--right .thumbs-arrow-next{bottom:0}:host.thumbs--left .thumbs-error,:host.thumbs--right .thumbs-error{border-bottom:1px solid #cecece}:host.thumbs--bottom,:host.thumbs--right{order:1}ul{outline:0;scrollbar-width:none;-webkit-overflow-scrolling:touch;transform:translateZ(0)}ul::-webkit-scrollbar{width:0;height:0}li{box-sizing:border-box;width:120px;height:80px;position:relative;cursor:pointer}li.thumbs-initial-item{visibility:hidden}li.thumbs-item--selected:after{content:\"\";display:block;position:absolute;left:0;bottom:0;width:100%;height:100%;border:10px solid rgba(255,255,255,.8117647059);box-sizing:border-box}img{width:100%;height:100%;background-repeat:no-repeat;background-position:center;object-fit:cover;color:transparent}.thumbs-error{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;flex-flow:column nowrap;justify-content:center;align-items:center;background:#e8e8e8;box-sizing:border-box}.thumbs-error-icon:not(.thumbs-error-icon--video){position:relative;border-left:16px solid transparent;border-right:16px solid transparent;border-bottom:28px solid #a5a5a5;margin-left:-8px}.thumbs-error-icon:not(.thumbs-error-icon--video):before,.thumbs-error-icon:not(.thumbs-error-icon--video):after{content:\"\";position:absolute}.thumbs-error-icon:not(.thumbs-error-icon--video):before{height:10px;width:10px;background-color:#a5a5a5;border-radius:100%;left:14px}.thumbs-error-icon:not(.thumbs-error-icon--video):after{border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:17px solid #a5a5a5;top:11px}.thumbs-error-icon--video{border-top:16px solid transparent;border-bottom:16px solid transparent;border-left:28px solid #a5a5a5;margin-left:9px}.thumbs-arrow{position:absolute;padding:0;background-color:transparent;cursor:pointer;z-index:10}.thumbs-arrow-prev{transform:scale(-1)}.thumbs-arrow>div{display:flex;justify-content:center;align-items:center;background:rgba(0,0,0,.5);padding:0;opacity:.7}@media (hover: hover) and (pointer: fine){.thumbs-arrow>div:hover{opacity:1}}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ChevronIconComponent, selector: "chevron-icon" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: ThumbsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'thumbs', changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, imports: [CommonModule, ChevronIconComponent], template: "<button\n  *ngIf=\"showStartArrow\"\n  aria-label=\"Previous thumbnails\"\n  class=\"thumbs-arrow thumbs-arrow-prev\"\n  (click)=\"slide(-1)\"\n>\n  <div *ngIf=\"!arrowTemplate; else $any(arrowTemplate)\">\n    <chevron-icon></chevron-icon>\n  </div>\n</button>\n\n<ul #thumbs [style.scrollBehavior]=\"scrollBehavior\" [class.rtl]=\"isRtl\">\n  <li *ngIf=\"!items || !items.length\" class=\"thumbs-initial-item\"></li>\n  <li\n    #thumb\n    *ngFor=\"let item of items; let i = index\"\n    [class.thumbs-item--selected]=\"i === selectedIndex\"\n    aria-hidden=\"true\"\n    (click)=\"emitEvent(i, item, $event, thumbClick)\"\n    (mouseenter)=\"emitEvent(i, item, $event, thumbHover)\"\n  >\n    <ng-container *ngIf=\"!thumbTemplate; else customThumbTemplate\">\n      <img\n        [src]=\"item.thumbSrc || ''\"\n        [alt]=\"item.alt\"\n        (load)=\"onLoadChange(item, true)\"\n        (error)=\"onLoadChange(item, false)\"\n      />\n\n      <ng-container *ngIf=\"item._thumbFailed\">\n        <div\n          *ngIf=\"!errorTemplate; else $any(errorTemplate)\"\n          class=\"thumbs-error\"\n        >\n          <div\n            class=\"thumbs-error-icon\"\n            [class.thumbs-error-icon--video]=\"item.video\"\n          ></div>\n        </div>\n      </ng-container>\n    </ng-container>\n\n    <ng-template #customThumbTemplate>\n      <ng-container\n        *ngTemplateOutlet=\"\n          $any(thumbTemplate);\n          context: { index: i, selectedIndex: selectedIndex, item: item }\n        \"\n      ></ng-container>\n    </ng-template>\n  </li>\n</ul>\n\n<button\n  *ngIf=\"showEndArrow\"\n  aria-label=\"Next thumbnails\"\n  class=\"thumbs-arrow thumbs-arrow-next\"\n  (click)=\"slide(1)\"\n>\n  <div *ngIf=\"!arrowTemplate; else $any(arrowTemplate)\">\n    <chevron-icon></chevron-icon>\n  </div>\n</button>\n", styles: [":host{flex:1 0 auto;position:relative;background-color:#f3f3f3}:host.thumbs--top,:host.thumbs--bottom{width:100%}:host.thumbs--top ul,:host.thumbs--bottom ul{width:100%;display:flex;overflow-x:scroll;overflow-y:hidden}:host.thumbs--top ul.rtl li:first-child,:host.thumbs--bottom ul.rtl li:first-child{margin-left:0;margin-right:auto}:host.thumbs--top ul.rtl li:last-child,:host.thumbs--bottom ul.rtl li:last-child{margin-right:0;margin-left:auto}:host.thumbs--top li,:host.thumbs--bottom li{flex:none}:host.thumbs--top li:not(:first-child),:host.thumbs--bottom li:not(:first-child){border-left:0}:host.thumbs--top li:first-child,:host.thumbs--bottom li:first-child{margin-left:auto}:host.thumbs--top li:last-child,:host.thumbs--bottom li:last-child{margin-right:auto}:host.thumbs--top .thumbs-arrow,:host.thumbs--bottom .thumbs-arrow{top:0;height:100%}:host.thumbs--top .thumbs-arrow>div,:host.thumbs--bottom .thumbs-arrow>div{width:30px;height:100%}:host.thumbs--top .thumbs-arrow-prev,:host.thumbs--bottom .thumbs-arrow-prev{left:0}:host.thumbs--top .thumbs-arrow-next,:host.thumbs--bottom .thumbs-arrow-next{right:0}:host.thumbs--top .thumbs-error,:host.thumbs--bottom .thumbs-error{border-right:1px solid #cecece}:host.thumbs--left,:host.thumbs--right{height:100%}:host.thumbs--left ul,:host.thumbs--right ul{height:100%;overflow-y:scroll;overflow-x:hidden}:host.thumbs--left li,:host.thumbs--right li{border-top:0}:host.thumbs--left .thumbs-arrow,:host.thumbs--right .thumbs-arrow{width:100%}:host.thumbs--left .thumbs-arrow>div,:host.thumbs--right .thumbs-arrow>div{width:100%;height:30px}:host.thumbs--left .thumbs-arrow chevron-icon,:host.thumbs--right .thumbs-arrow chevron-icon{transform:rotate(90deg)}:host.thumbs--left .thumbs-arrow-prev,:host.thumbs--right .thumbs-arrow-prev{top:0}:host.thumbs--left .thumbs-arrow-next,:host.thumbs--right .thumbs-arrow-next{bottom:0}:host.thumbs--left .thumbs-error,:host.thumbs--right .thumbs-error{border-bottom:1px solid #cecece}:host.thumbs--bottom,:host.thumbs--right{order:1}ul{outline:0;scrollbar-width:none;-webkit-overflow-scrolling:touch;transform:translateZ(0)}ul::-webkit-scrollbar{width:0;height:0}li{box-sizing:border-box;width:120px;height:80px;position:relative;cursor:pointer}li.thumbs-initial-item{visibility:hidden}li.thumbs-item--selected:after{content:\"\";display:block;position:absolute;left:0;bottom:0;width:100%;height:100%;border:10px solid rgba(255,255,255,.8117647059);box-sizing:border-box}img{width:100%;height:100%;background-repeat:no-repeat;background-position:center;object-fit:cover;color:transparent}.thumbs-error{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;flex-flow:column nowrap;justify-content:center;align-items:center;background:#e8e8e8;box-sizing:border-box}.thumbs-error-icon:not(.thumbs-error-icon--video){position:relative;border-left:16px solid transparent;border-right:16px solid transparent;border-bottom:28px solid #a5a5a5;margin-left:-8px}.thumbs-error-icon:not(.thumbs-error-icon--video):before,.thumbs-error-icon:not(.thumbs-error-icon--video):after{content:\"\";position:absolute}.thumbs-error-icon:not(.thumbs-error-icon--video):before{height:10px;width:10px;background-color:#a5a5a5;border-radius:100%;left:14px}.thumbs-error-icon:not(.thumbs-error-icon--video):after{border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:17px solid #a5a5a5;top:11px}.thumbs-error-icon--video{border-top:16px solid transparent;border-bottom:16px solid transparent;border-left:28px solid #a5a5a5;margin-left:9px}.thumbs-arrow{position:absolute;padding:0;background-color:transparent;cursor:pointer;z-index:10}.thumbs-arrow-prev{transform:scale(-1)}.thumbs-arrow>div{display:flex;justify-content:center;align-items:center;background:rgba(0,0,0,.5);padding:0;opacity:.7}@media (hover: hover) and (pointer: fine){.thumbs-arrow>div:hover{opacity:1}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, propDecorators: { items: [{
                type: Input
            }], selectedIndex: [{
                type: Input
            }], aria: [{
                type: Input
            }], orientation: [{
                type: Input
            }], arrows: [{
                type: Input
            }], arrowSlideByLength: [{
                type: Input
            }], autoScroll: [{
                type: Input
            }], thumbTemplate: [{
                type: Input
            }], arrowTemplate: [{
                type: Input
            }], errorTemplate: [{
                type: Input
            }], scrollBehavior: [{
                type: Input
            }], isRtl: [{
                type: Input
            }], thumbClick: [{
                type: Output
            }], thumbHover: [{
                type: Output
            }], thumbListRef: [{
                type: ViewChild,
                args: ['thumbs', { static: true }]
            }], thumbsRef: [{
                type: ViewChildren,
                args: ['thumb']
            }], cssClass: [{
                type: HostBinding,
                args: ['class']
            }] } });

class MediaDirective {
    constructor(hostRef) {
        this.mediaLoadError = new EventEmitter();
        this.onLoad = (ev) => {
            if (ev.type === 'error') {
                this.mediaLoadError.emit();
            }
        };
        this.nativeEl = hostRef.nativeElement;
    }
    ngOnInit() {
        this.nativeEl.addEventListener('error', this.onLoad, true);
    }
    ngOnDestroy() {
        this.nativeEl.removeEventListener('error', this.onLoad, true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: MediaDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.8", type: MediaDirective, isStandalone: true, selector: "[media]", outputs: { mediaLoadError: "mediaLoadError" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: MediaDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[media]',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { mediaLoadError: [{
                type: Output
            }] } });

class SafePipe {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    transform(url) {
        return this.sanitizer.bypassSecurityTrustResourceUrl(url);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: SafePipe, deps: [{ token: i1$1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.1.8", ngImport: i0, type: SafePipe, isStandalone: true, name: "safe" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: SafePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'safe',
                    standalone: true,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.DomSanitizer }]; } });

class CounterComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: CounterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.8", type: CounterComponent, isStandalone: true, selector: "counter", inputs: { itemQuantity: "itemQuantity", selectedIndex: "selectedIndex", orientation: "orientation" }, host: { properties: { "class": "this.orientation" } }, ngImport: i0, template: `
    <span aria-hidden="true">
      {{ selectedIndex + 1 }}/{{ itemQuantity || 0 }}
    </span>
  `, isInline: true, styles: [":host{position:absolute;left:50%;transform:translate(-50%);background:rgba(0,0,0,.6);padding:.25rem .5rem;font-size:.9rem;color:#f1f5f9;letter-spacing:3px;-webkit-user-select:none;user-select:none}:host.top{top:0;border-bottom-left-radius:.375rem;border-bottom-right-radius:.375rem}:host.bottom{bottom:0;border-top-left-radius:.375rem;border-top-right-radius:.375rem}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: CounterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'counter', template: `
    <span aria-hidden="true">
      {{ selectedIndex + 1 }}/{{ itemQuantity || 0 }}
    </span>
  `, changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, styles: [":host{position:absolute;left:50%;transform:translate(-50%);background:rgba(0,0,0,.6);padding:.25rem .5rem;font-size:.9rem;color:#f1f5f9;letter-spacing:3px;-webkit-user-select:none;user-select:none}:host.top{top:0;border-bottom-left-radius:.375rem;border-bottom-right-radius:.375rem}:host.bottom{bottom:0;border-top-left-radius:.375rem;border-top-right-radius:.375rem}\n"] }]
        }], propDecorators: { itemQuantity: [{
                type: Input
            }], selectedIndex: [{
                type: Input
            }], orientation: [{
                type: HostBinding,
                args: ['class']
            }, {
                type: Input
            }] } });

const passiveEventListenerOpts = {
    passive: true,
};
class ViewerComponent {
    set noAnimation(value) {
        this.itemListRef.nativeElement.style.transitionDuration = value
            ? '0ms'
            : '400ms';
    }
    get counterIndex() {
        return Math.floor(this.selectedIndex / this.moveByItems);
    }
    get showArrow() {
        return this.arrows && this.items && this.items.length > 1;
    }
    get showPrevArrow() {
        return this.showArrow && (this.selectedIndex > 0 || this.reallyLoop);
    }
    get showNextArrow() {
        return (this.showArrow &&
            (this.selectedIndex < this.items.length - 1 || this.reallyLoop));
    }
    constructor(_hostRef, _cd, _destroyRef, _zone) {
        this._hostRef = _hostRef;
        this._cd = _cd;
        this._destroyRef = _destroyRef;
        this._zone = _zone;
        this.itemClick = new EventEmitter();
        this.descriptionClick = new EventEmitter();
        this.selection = new EventEmitter();
        this.fringeCount = this.getFringeCount();
        this._itemWidth = 0;
        this.pointerDeltaX = 0;
        this.sliding = false;
        this.repositionOnFringe = entries => {
            if (!this.reallyLoop || !this.sliding) {
                return;
            }
            const { first } = this.itemsRef;
            const visibleEntries = entries.filter(e => e.isIntersecting);
            if (visibleEntries.length === 0) {
                return;
            }
            const beginningVisible = entries[0].target === first.nativeElement;
            this.pointerDeltaX +=
                (beginningVisible ? -1 : 1) * this.items.length * this._itemWidth;
        };
        this.updateDimensions = () => {
            this._itemWidth =
                this._hostRef.nativeElement.querySelector('li').offsetWidth;
        };
        this.shiftByDelta = (delta) => {
            this.pointerDeltaX += delta;
            this.shift(this.pointerDeltaX);
        };
    }
    ngOnChanges({ visibleItems, items, loop }) {
        if (visibleItems) {
            this.itemListRef.nativeElement.style.setProperty('--item-width', `calc(100% / ${this.visibleItems})`);
            setTimeout(this.updateDimensions);
        }
        if (loop || items) {
            this.reallyLoop = this.items.length > 1 ? this.loop : false;
            if (this.reallyLoop) {
                setTimeout(() => this.observeFringes());
            }
        }
        if (items || visibleItems || loop) {
            this.fringeCount = this.getFringeCount();
            this.displayedItems = this.getItemsToBeDisplayed(this.fringeCount);
        }
    }
    ngOnInit() {
        if (isBrowser) {
            this.handleResizes();
            if (this.mouseGestures) {
                this.handleMouseSlides();
            }
            if (this.touchGestures) {
                this.handleTouchSlides();
            }
            this._destroyRef.onDestroy(() => this.fringeObserver?.disconnect());
        }
    }
    ngAfterViewInit() {
        this.center();
        setTimeout(() => (this.noAnimation = false));
    }
    isYoutube(item) {
        return !!item.src.match(/youtube.*\/embed\//);
    }
    select(index, shortPath = true) {
        if (this.selectedIndex === index) {
            return this.center();
        }
        if (this.items[this.selectedIndex]?.video) {
            this.stopCurrentVideo();
        }
        // The purpose of the short path here is best understood by the following example: If going from index
        // 6 (last) to index 0, do not go back over all the middle items, but go 6 -> 0 the short route. This
        // makes navigating slider smoother. This of course applies in the other direction as well.
        if (this.visibleItems > 1 && shortPath) {
            const maxIndex = this.items.length - this.visibleItems;
            // When going back, in direction over the first item, stop at the slider's beginning at first.
            if (this.selectedIndex !== 0 && index < 0) {
                index = 0;
            }
            else if (this.selectedIndex < maxIndex) {
                // Set the desired index or choose the last if it is the slider's last "page".
                index = Math.min(maxIndex, index);
            }
            else if (index > maxIndex) {
                // Loop to the first item if going over the slider's end. This trick makes the loop cross the
                // boundary between the last and the first.
                index = this.items.length;
            }
        }
        const indexOutOfBounds = !this.items[index];
        const looping = this.reallyLoop && indexOutOfBounds;
        if (looping) {
            this.loopTo(index);
            return this.selection.emit(this.selectedIndex);
        }
        this.selectedIndex = indexOutOfBounds
            ? this.correctIndexOutOfBounds(index)
            : index;
        this.center(); // we center only for this branch since looping does a delayed centering
        this.selection.emit(this.selectedIndex);
    }
    selectByDelta(delta) {
        this.select(this.selectedIndex + delta);
    }
    onImageClick(item, event) {
        this.itemClick.emit({
            event,
            item,
            index: this.items.indexOf(item),
        });
    }
    onTab(nextItemIndex) {
        nextItemIndex = nextItemIndex - this.fringeCount;
        // allow focus to escape viewer
        if (nextItemIndex >= 0 && nextItemIndex < this.items.length) {
            this.select(nextItemIndex);
            // focusing an item literally scrolls the item list, so I have to scroll it back
            requestAnimationFrame(() => (this._hostRef.nativeElement.scrollLeft = 0));
        }
    }
    onItemErrored(item) {
        if (!this.showErrors) {
            return;
        }
        item._failed = true;
        this._cd.detectChanges();
    }
    itemFailedToLoad(item) {
        return item._failed;
    }
    itemTabbable(index) {
        index = index - this.fringeCount;
        return index >= 0 && index < this.items.length ? 0 : -1;
    }
    center() {
        this.shift();
    }
    correctIndexOutOfBounds(index) {
        return index < 0 ? 0 : this.items.length - 1;
    }
    getFringeCount() {
        return this.reallyLoop
            ? Math.min(Math.ceil(this.visibleItems), this.items.length)
            : 0;
    }
    getItemsToBeDisplayed(fringeCount) {
        return this.reallyLoop
            ? [
                ...this.items.slice(-fringeCount),
                ...this.items,
                ...this.items.slice(0, fringeCount),
            ]
            : this.items;
    }
    handleMouseSlides() {
        this._zone.runOutsideAngular(() => {
            const hostEl = this._hostRef.nativeElement;
            let mousedown;
            let maxDeltaX = 0;
            let maxDeltaY = 0;
            const onmousedown = (e) => {
                mousedown = e;
                this.noAnimation = this.sliding = true;
                document.addEventListener('mousemove', onmousemove, passiveEventListenerOpts);
                document.addEventListener('mouseup', onmouseup, passiveEventListenerOpts);
            };
            const onmousemove = (e) => {
                maxDeltaX = Math.max(Math.abs(mousedown.x - e.x));
                maxDeltaY = Math.max(Math.abs(mousedown.y - e.y));
                this.shiftByDelta(e.movementX);
            };
            const onmouseup = () => {
                this.noAnimation = this.sliding = false;
                this._zone.run(() => this.selectBySwipeStats(this.pointerDeltaX));
                this.pointerDeltaX = 0;
                document.removeEventListener('mousemove', onmousemove);
                document.removeEventListener('mouseup', onmouseup);
            };
            const onclick = (e) => {
                if (maxDeltaX > 10 || maxDeltaY > 10) {
                    e.stopPropagation();
                    // to prevent playing a video on swipe
                    e.preventDefault();
                }
                maxDeltaY = maxDeltaX = 0;
            };
            const ondragstart = (e) => e.preventDefault();
            hostEl.addEventListener('mousedown', onmousedown, passiveEventListenerOpts);
            hostEl.addEventListener('click', onclick, { capture: true });
            hostEl.addEventListener('dragstart', ondragstart);
            this._destroyRef.onDestroy(() => {
                hostEl.removeEventListener('mousedown', onmousedown);
                hostEl.removeEventListener('click', onclick);
                hostEl.removeEventListener('dragstart', ondragstart);
            });
        });
    }
    handleTouchSlides() {
        this._zone.runOutsideAngular(() => {
            const hostEl = this._hostRef.nativeElement;
            let horizontal;
            let touchstart;
            let lastTouchmove;
            const ontouchstart = (e) => {
                touchstart = e;
                this.noAnimation = this.sliding = true;
            };
            const ontouchmove = (e) => {
                if (!touchstart || e.touches.length !== 1) {
                    return;
                }
                const startTouch = touchstart.touches[0];
                const moveTouch = e.touches[0];
                if (horizontal == null) {
                    const deltaX = Math.abs(moveTouch.clientX - startTouch.clientX);
                    const deltaY = Math.abs(moveTouch.clientY - startTouch.clientY);
                    if (deltaX || deltaY) {
                        horizontal = deltaX * 1.2 >= deltaY;
                    }
                }
                if (horizontal) {
                    this.shiftByDelta(moveTouch.clientX - (lastTouchmove ?? touchstart).touches[0].clientX);
                    lastTouchmove = e;
                    if (UA.ios) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            };
            const ontouchend = () => {
                this.noAnimation = this.sliding = false;
                this._zone.run(() => this.selectBySwipeStats(this.pointerDeltaX));
                this.pointerDeltaX = 0;
                horizontal = undefined;
                touchstart = undefined;
                lastTouchmove = undefined;
            };
            hostEl.addEventListener('touchstart', ontouchstart, passiveEventListenerOpts);
            document.addEventListener('touchmove', ontouchmove, {
                passive: !UA.ios,
            });
            document.addEventListener('touchend', ontouchend, passiveEventListenerOpts);
            this._destroyRef.onDestroy(() => {
                hostEl.removeEventListener('touchstart', ontouchstart);
                document.removeEventListener('touchmove', ontouchmove);
                document.removeEventListener('touchend', ontouchend);
            });
        });
    }
    handleResizes() {
        window.addEventListener('resize', this.updateDimensions, passiveEventListenerOpts);
        this._destroyRef.onDestroy(() => {
            window.removeEventListener('resize', this.updateDimensions);
        });
    }
    loopTo(desiredIndex) {
        this.noAnimation = true;
        const shift = Math.sign(desiredIndex) * this.items.length * this._itemWidth;
        this.shiftByDelta(shift);
        this.selectedIndex =
            desiredIndex < 0
                ? desiredIndex + this.items.length
                : desiredIndex - this.items.length;
        // NOTE: This is needed so that animation is reactivated really only after the loop shift
        // happened. Without the requestAnimationFrame, the setTimeout is often not enough, as it
        // can happen still before the next frame is painted, which would cause the loop shift
        // to be animated.
        // But, requestAnimationFrame is not enough as its callback is called BEFORE the next paint,
        // not after. Second requestAnimationFrame would also be possible, but setTimeout is better
        // as it's called right after the next paint happens.
        requestAnimationFrame(() => setTimeout(() => {
            this.pointerDeltaX = 0;
            this.noAnimation = false;
            this.center();
        }));
    }
    observeFringes() {
        if (!isBrowser) {
            return;
        }
        this.fringeObserver?.disconnect();
        const observer = new IntersectionObserver(this.repositionOnFringe, {
            root: this._hostRef.nativeElement,
            threshold: 1.0,
        });
        observer.observe(this.itemsRef.first.nativeElement);
        observer.observe(this.itemsRef.last.nativeElement);
        this.fringeObserver = observer;
    }
    selectBySwipeStats(distance) {
        // I use round instead of previous ceil here because the ceil was pretty one-sided in where the
        // index delta would move. This was apparent in looping mode, where items that were clearly to be
        // scrolled to were actually hidden in favor of items that were barely visible, but selected thanks
        // to Math.ceil.
        // Now I use magical constant 2.25 to make sure a tiny swipe slides to next items, but there is still
        // a tiny threshold to make sure the slide doesn't always happen.
        const indexDelta = Math.round((Math.abs(distance) + this._itemWidth / 2.25) / this._itemWidth) * -Math.sign(distance);
        const newIndex = this.selectedIndex + indexDelta;
        this.select(newIndex, false);
    }
    shift(delta = 0) {
        const multiplier = this.isRtl ? 1 : -1;
        const index = (this.selectedIndex + this.fringeCount) * multiplier;
        delta *= -multiplier;
        const shift = `calc(${index} * var(--item-width) + ${delta}px)`;
        this.itemListRef.nativeElement.style.transform = `translate3d(${shift}, 0, 0)`;
    }
    stopCurrentVideo() {
        const videoEl = this.itemsRef
            .get(this.selectedIndex)
            ?.nativeElement.querySelector('video');
        if (videoEl) {
            videoEl.pause();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: ViewerComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.DestroyRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.8", type: ViewerComponent, isStandalone: true, selector: "viewer", inputs: { items: "items", selectedIndex: "selectedIndex", arrows: "arrows", descriptions: "descriptions", errorText: "errorText", showErrors: "showErrors", mouseGestures: "mouseGestures", touchGestures: "touchGestures", counter: "counter", counterOrientation: "counterOrientation", loading: "loading", objectFit: "objectFit", itemTemplate: "itemTemplate", errorTemplate: "errorTemplate", arrowTemplate: "arrowTemplate", contentTemplate: "contentTemplate", thumbsOrientation: "thumbsOrientation", aria: "aria", loop: "loop", visibleItems: "visibleItems", moveByItems: "moveByItems", clip: "clip", isRtl: "isRtl" }, outputs: { itemClick: "itemClick", descriptionClick: "descriptionClick", selection: "selection" }, host: { properties: { "class.clip": "this.clip", "class.rtl": "this.isRtl" } }, viewQueries: [{ propertyName: "itemListRef", first: true, predicate: ["itemList"], descendants: true, static: true }, { propertyName: "itemsRef", predicate: ["itemsRef"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<button\n  *ngIf=\"showPrevArrow\"\n  aria-label=\"Previous image\"\n  class=\"viewer-arrow viewer-arrow-prev\"\n  (mousedown)=\"$event.stopPropagation()\"\n  (click)=\"selectByDelta(-moveByItems)\"\n>\n  <chevron-icon *ngIf=\"!arrowTemplate; else $any(arrowTemplate)\"></chevron-icon>\n</button>\n\n<ul #itemList [attr.aria-label]=\"aria?.viewerLabel\">\n  <li *ngIf=\"!displayedItems?.length\" class=\"viewer-initial-item\"></li>\n  <li\n    #itemsRef\n    *ngFor=\"let item of displayedItems; let i = index\"\n    media\n    [attr.tabindex]=\"itemTabbable(i)\"\n    [attr.aria-label]=\"item.alt\"\n    [attr.aria-describedby]=\"'viewer-aria-description-' + i\"\n    (click)=\"onImageClick(item, $event)\"\n    (mediaLoadError)=\"onItemErrored(item)\"\n    (keydown.Tab)=\"onTab(i + 1)\"\n    (keydown.shift.Tab)=\"onTab(i - 1)\"\n  >\n    <ng-container *ngIf=\"!itemTemplate; else customTemplate\">\n      <picture *ngIf=\"!item.video\" @mediaAnimate>\n        <source\n          *ngFor=\"let source of item.pictureSources\"\n          [srcset]=\"source.srcset\"\n          [attr.media]=\"source.media\"\n          [attr.sizes]=\"source.sizes\"\n          [attr.type]=\"source.type\"\n        />\n        <img\n          [src]=\"item.src\"\n          [alt]=\"item.alt\"\n          [attr.loading]=\"loading\"\n          [style.objectFit]=\"objectFit\"\n        />\n      </picture>\n      <!-- Using loadedmetadata instead of loadeddata because iOS loads data lazily upon user's interaction -->\n      <video\n        *ngIf=\"!isYoutube(item) && item.video\"\n        @mediaAnimate\n        [src]=\"item.src\"\n        [poster]=\"item.thumbSrc || ''\"\n        [attr.preload]=\"loading === 'lazy' ? 'metadata' : 'auto'\"\n        [style.objectFit]=\"objectFit\"\n        controls\n        playsinline\n      ></video>\n\n      <iframe\n        *ngIf=\"isYoutube(item)\"\n        @mediaAnimate\n        [attr.loading]=\"loading\"\n        [src]=\"item.src | safe\"\n        allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen\n      ></iframe>\n    </ng-container>\n\n    <ng-container *ngIf=\"itemFailedToLoad(item)\">\n      <div\n        *ngIf=\"!errorTemplate; else $any(errorTemplate)\"\n        class=\"viewer-error\"\n      >\n        <div class=\"viewer-error-icon\">\u26A0</div>\n        <p class=\"viewer-error-text\">\n          {{ errorText || 'Loading of this media failed' }}\n        </p>\n      </div>\n    </ng-container>\n\n    <span\n      [id]=\"'viewer-aria-description-' + i\"\n      class=\"sr-only\"\n      [innerHTML]=\"item.description\"\n    ></span>\n\n    <ng-template #customTemplate>\n      <ng-container\n        *ngTemplateOutlet=\"\n          $any(itemTemplate);\n          context: {\n            index: items?.indexOf(item),\n            selectedIndex: selectedIndex,\n            item: item,\n            video: item.video\n          }\n        \"\n      ></ng-container>\n    </ng-template>\n  </li>\n</ul>\n\n<button\n  *ngIf=\"showNextArrow\"\n  aria-label=\"Next image\"\n  class=\"viewer-arrow viewer-arrow-next\"\n  (mousedown)=\"$event.stopPropagation()\"\n  (click)=\"selectByDelta(moveByItems)\"\n>\n  <chevron-icon *ngIf=\"!arrowTemplate; else $any(arrowTemplate)\"></chevron-icon>\n</button>\n\n<counter\n  *ngIf=\"counter && items.length\"\n  [itemQuantity]=\"items.length\"\n  [selectedIndex]=\"counterIndex\"\n  [orientation]=\"counterOrientation\"\n></counter>\n\n<ng-container\n  *ngTemplateOutlet=\"\n    $any(contentTemplate);\n    context: {\n      selectedIndex: selectedIndex\n    }\n  \"\n></ng-container>\n\n<div\n  *ngIf=\"descriptions && items\"\n  class=\"viewer-description\"\n  [class.viewer-description--above-counter]=\"\n    counter && counterOrientation === 'bottom'\n  \"\n  aria-hidden=\"true\"\n>\n  <div\n    *ngIf=\"items[selectedIndex]?.description as description\"\n    class=\"viewer-description-inner\"\n    [innerHTML]=\"description\"\n    (click)=\"descriptionClick.emit($event)\"\n  ></div>\n</div>\n", styles: [":host{display:block;position:relative;width:100%;height:100%;outline:none;z-index:1}:host.clip{overflow:hidden}:host.rtl .viewer-arrow-next{right:auto;left:0;transform:translateY(-50%) scale(-1)}:host.rtl .viewer-arrow-prev{right:0;left:auto;transform:translateY(-50%)}ul{--item-width: 100%;display:flex;width:100%;height:100%;transition:transform;scrollbar-width:none}ul::-webkit-scrollbar{width:0;height:0}li{display:flex;align-items:center;flex:none;position:relative;width:var(--item-width);-webkit-user-select:none;user-select:none;outline:0}picture{width:100%;height:100%}img,video,iframe{width:100%;height:100%;background-color:transparent;outline:0;color:transparent}iframe{border:0}img{-webkit-user-select:none;user-select:none}.viewer-description{position:absolute;bottom:.5rem;width:100%;display:flex;justify-content:center;font-size:.9rem}.viewer-description--above-counter{bottom:2.5rem}.viewer-description-inner{display:inline-block;background:rgba(0,0,0,.7);color:#f1f5f9;padding:.5rem .75rem;max-width:80%;text-align:center;border-radius:.5rem}.viewer-error{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;flex-flow:column nowrap;justify-content:center;align-items:center;background-color:#f5f5f5;color:#7d7d7d}.viewer-error-icon{font-size:40px}.viewer-error-text{margin-top:10px;letter-spacing:.01em}.viewer-arrow{display:flex;position:absolute;top:50%;padding:0;background-color:transparent;transform:translateY(-50%);z-index:100;cursor:pointer}.viewer-arrow-prev{left:0;transform:scale(-1) translateY(50%)}.viewer-arrow-next{right:0}.viewer-arrow chevron-icon{margin:15px 6px;opacity:.7}@media (hover: hover) and (pointer: fine){.viewer-arrow chevron-icon:hover{opacity:1}}.viewer-arrow chevron-icon::ng-deep svg{height:32px;width:32px}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: CounterComponent, selector: "counter", inputs: ["itemQuantity", "selectedIndex", "orientation"] }, { kind: "component", type: ChevronIconComponent, selector: "chevron-icon" }, { kind: "directive", type: MediaDirective, selector: "[media]", outputs: ["mediaLoadError"] }, { kind: "pipe", type: SafePipe, name: "safe" }], animations: [
            trigger('mediaAnimate', [
                transition(':leave', animate('0ms 100ms')),
                transition(':enter', [
                    style({ opacity: 0 }),
                    animate('400ms', style({ opacity: 1 })),
                ]),
            ]),
        ], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: ViewerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'viewer', changeDetection: ChangeDetectionStrategy.OnPush, animations: [
                        trigger('mediaAnimate', [
                            transition(':leave', animate('0ms 100ms')),
                            transition(':enter', [
                                style({ opacity: 0 }),
                                animate('400ms', style({ opacity: 1 })),
                            ]),
                        ]),
                    ], standalone: true, imports: [
                        CommonModule,
                        CounterComponent,
                        ChevronIconComponent,
                        MediaDirective,
                        SafePipe,
                    ], template: "<button\n  *ngIf=\"showPrevArrow\"\n  aria-label=\"Previous image\"\n  class=\"viewer-arrow viewer-arrow-prev\"\n  (mousedown)=\"$event.stopPropagation()\"\n  (click)=\"selectByDelta(-moveByItems)\"\n>\n  <chevron-icon *ngIf=\"!arrowTemplate; else $any(arrowTemplate)\"></chevron-icon>\n</button>\n\n<ul #itemList [attr.aria-label]=\"aria?.viewerLabel\">\n  <li *ngIf=\"!displayedItems?.length\" class=\"viewer-initial-item\"></li>\n  <li\n    #itemsRef\n    *ngFor=\"let item of displayedItems; let i = index\"\n    media\n    [attr.tabindex]=\"itemTabbable(i)\"\n    [attr.aria-label]=\"item.alt\"\n    [attr.aria-describedby]=\"'viewer-aria-description-' + i\"\n    (click)=\"onImageClick(item, $event)\"\n    (mediaLoadError)=\"onItemErrored(item)\"\n    (keydown.Tab)=\"onTab(i + 1)\"\n    (keydown.shift.Tab)=\"onTab(i - 1)\"\n  >\n    <ng-container *ngIf=\"!itemTemplate; else customTemplate\">\n      <picture *ngIf=\"!item.video\" @mediaAnimate>\n        <source\n          *ngFor=\"let source of item.pictureSources\"\n          [srcset]=\"source.srcset\"\n          [attr.media]=\"source.media\"\n          [attr.sizes]=\"source.sizes\"\n          [attr.type]=\"source.type\"\n        />\n        <img\n          [src]=\"item.src\"\n          [alt]=\"item.alt\"\n          [attr.loading]=\"loading\"\n          [style.objectFit]=\"objectFit\"\n        />\n      </picture>\n      <!-- Using loadedmetadata instead of loadeddata because iOS loads data lazily upon user's interaction -->\n      <video\n        *ngIf=\"!isYoutube(item) && item.video\"\n        @mediaAnimate\n        [src]=\"item.src\"\n        [poster]=\"item.thumbSrc || ''\"\n        [attr.preload]=\"loading === 'lazy' ? 'metadata' : 'auto'\"\n        [style.objectFit]=\"objectFit\"\n        controls\n        playsinline\n      ></video>\n\n      <iframe\n        *ngIf=\"isYoutube(item)\"\n        @mediaAnimate\n        [attr.loading]=\"loading\"\n        [src]=\"item.src | safe\"\n        allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen\n      ></iframe>\n    </ng-container>\n\n    <ng-container *ngIf=\"itemFailedToLoad(item)\">\n      <div\n        *ngIf=\"!errorTemplate; else $any(errorTemplate)\"\n        class=\"viewer-error\"\n      >\n        <div class=\"viewer-error-icon\">\u26A0</div>\n        <p class=\"viewer-error-text\">\n          {{ errorText || 'Loading of this media failed' }}\n        </p>\n      </div>\n    </ng-container>\n\n    <span\n      [id]=\"'viewer-aria-description-' + i\"\n      class=\"sr-only\"\n      [innerHTML]=\"item.description\"\n    ></span>\n\n    <ng-template #customTemplate>\n      <ng-container\n        *ngTemplateOutlet=\"\n          $any(itemTemplate);\n          context: {\n            index: items?.indexOf(item),\n            selectedIndex: selectedIndex,\n            item: item,\n            video: item.video\n          }\n        \"\n      ></ng-container>\n    </ng-template>\n  </li>\n</ul>\n\n<button\n  *ngIf=\"showNextArrow\"\n  aria-label=\"Next image\"\n  class=\"viewer-arrow viewer-arrow-next\"\n  (mousedown)=\"$event.stopPropagation()\"\n  (click)=\"selectByDelta(moveByItems)\"\n>\n  <chevron-icon *ngIf=\"!arrowTemplate; else $any(arrowTemplate)\"></chevron-icon>\n</button>\n\n<counter\n  *ngIf=\"counter && items.length\"\n  [itemQuantity]=\"items.length\"\n  [selectedIndex]=\"counterIndex\"\n  [orientation]=\"counterOrientation\"\n></counter>\n\n<ng-container\n  *ngTemplateOutlet=\"\n    $any(contentTemplate);\n    context: {\n      selectedIndex: selectedIndex\n    }\n  \"\n></ng-container>\n\n<div\n  *ngIf=\"descriptions && items\"\n  class=\"viewer-description\"\n  [class.viewer-description--above-counter]=\"\n    counter && counterOrientation === 'bottom'\n  \"\n  aria-hidden=\"true\"\n>\n  <div\n    *ngIf=\"items[selectedIndex]?.description as description\"\n    class=\"viewer-description-inner\"\n    [innerHTML]=\"description\"\n    (click)=\"descriptionClick.emit($event)\"\n  ></div>\n</div>\n", styles: [":host{display:block;position:relative;width:100%;height:100%;outline:none;z-index:1}:host.clip{overflow:hidden}:host.rtl .viewer-arrow-next{right:auto;left:0;transform:translateY(-50%) scale(-1)}:host.rtl .viewer-arrow-prev{right:0;left:auto;transform:translateY(-50%)}ul{--item-width: 100%;display:flex;width:100%;height:100%;transition:transform;scrollbar-width:none}ul::-webkit-scrollbar{width:0;height:0}li{display:flex;align-items:center;flex:none;position:relative;width:var(--item-width);-webkit-user-select:none;user-select:none;outline:0}picture{width:100%;height:100%}img,video,iframe{width:100%;height:100%;background-color:transparent;outline:0;color:transparent}iframe{border:0}img{-webkit-user-select:none;user-select:none}.viewer-description{position:absolute;bottom:.5rem;width:100%;display:flex;justify-content:center;font-size:.9rem}.viewer-description--above-counter{bottom:2.5rem}.viewer-description-inner{display:inline-block;background:rgba(0,0,0,.7);color:#f1f5f9;padding:.5rem .75rem;max-width:80%;text-align:center;border-radius:.5rem}.viewer-error{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;flex-flow:column nowrap;justify-content:center;align-items:center;background-color:#f5f5f5;color:#7d7d7d}.viewer-error-icon{font-size:40px}.viewer-error-text{margin-top:10px;letter-spacing:.01em}.viewer-arrow{display:flex;position:absolute;top:50%;padding:0;background-color:transparent;transform:translateY(-50%);z-index:100;cursor:pointer}.viewer-arrow-prev{left:0;transform:scale(-1) translateY(50%)}.viewer-arrow-next{right:0}.viewer-arrow chevron-icon{margin:15px 6px;opacity:.7}@media (hover: hover) and (pointer: fine){.viewer-arrow chevron-icon:hover{opacity:1}}.viewer-arrow chevron-icon::ng-deep svg{height:32px;width:32px}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.DestroyRef }, { type: i0.NgZone }]; }, propDecorators: { items: [{
                type: Input
            }], selectedIndex: [{
                type: Input
            }], arrows: [{
                type: Input
            }], descriptions: [{
                type: Input
            }], errorText: [{
                type: Input
            }], showErrors: [{
                type: Input
            }], mouseGestures: [{
                type: Input
            }], touchGestures: [{
                type: Input
            }], counter: [{
                type: Input
            }], counterOrientation: [{
                type: Input
            }], loading: [{
                type: Input
            }], objectFit: [{
                type: Input
            }], itemTemplate: [{
                type: Input
            }], errorTemplate: [{
                type: Input
            }], arrowTemplate: [{
                type: Input
            }], contentTemplate: [{
                type: Input
            }], thumbsOrientation: [{
                type: Input
            }], aria: [{
                type: Input
            }], loop: [{
                type: Input
            }], visibleItems: [{
                type: Input
            }], moveByItems: [{
                type: Input
            }], clip: [{
                type: HostBinding,
                args: ['class.clip']
            }, {
                type: Input
            }], isRtl: [{
                type: HostBinding,
                args: ['class.rtl']
            }, {
                type: Input
            }], itemClick: [{
                type: Output
            }], descriptionClick: [{
                type: Output
            }], selection: [{
                type: Output
            }], itemListRef: [{
                type: ViewChild,
                args: ['itemList', { static: true }]
            }], itemsRef: [{
                type: ViewChildren,
                args: ['itemsRef']
            }] } });

class GalleryComponent {
    constructor() {
        /**
         * Gallery items to display
         */
        this.items = [];
        /**
         * Initially selected item, 0-based
         */
        this.selectedIndex = 0;
        /**
         * Aria labels
         */
        this.aria = defaultAria;
        /**
         * Show left and right icons to navigate between images in the viewer
         */
        this.arrows = true;
        /**
         * Displayes item descriptions if any are present in `GalleryItem`
         */
        this.descriptions = false;
        /**
         * Display an error when the media contained in gallery item failed to load.
         */
        this.showErrors = false;
        /**
         * Allow mouse swipes
         */
        this.mouseGestures = true;
        /**
         * Allow touch swipes
         */
        this.touchGestures = true;
        /**
         * Controls whether items outside gallery's scrollport should overflow it. When clip == false,
         * items overflowing the gallery will be visible on both sides. Otherwise they will be hidden
         * with `overflow: hidden`.
         */
        this.clip = true;
        /**
         * Show item counter in the slider area
         */
        this.counter = true;
        this.counterOrientation = 'bottom';
        /**
         * Either makes images load eagerly or lazily. The lazy loading is managed by the browser itself.
         */
        this.loading = 'lazy';
        /**
         * Turns on infinite looping for swiping and arrows navigation.
         */
        this.loop = false;
        /**
         * The way an image or video should fill its container.
         */
        this.objectFit = 'cover';
        /**
         * Right to left mode
         */
        this.isRtl = false;
        /**
         * How many items are visible in the scrollport.
         */
        this.visibleItems = 1;
        /**
         * By how many items the slider shifts when user navigates with arrows.
         */
        this.moveByItems = this.visibleItems;
        /**
         * Show thumbnail list.
         */
        this.thumbs = true;
        /**
         * Scroll thumbnails automatically as you navigate in image viewer.
         */
        this.thumbsAutoScroll = true;
        /**
         * Where thumbnails will be placed in relation to slider.
         */
        this.thumbsOrientation = 'bottom';
        /**
         * Show arrows to navigate thumbnails.
         */
        this.thumbsArrows = true;
        /**
         * Smooth or instant navigation in thumbnails.
         */
        this.thumbsScrollBehavior = 'smooth';
        this.itemClick = new EventEmitter();
        this.thumbClick = new EventEmitter();
        this.thumbHover = new EventEmitter();
        this.descriptionClick = new EventEmitter();
        /**
         * Triggers when item or group of items gets selected, ie. they get displayed in scrollport.
         */
        this.selection = new EventEmitter();
    }
    get _galleryColumn() {
        return (this.thumbsOrientation === 'top' || this.thumbsOrientation === 'bottom');
    }
    get _thumbsOrientationFlag() {
        return this._galleryColumn
            ? 6 /* OrientationFlag.HORIZONTAL */
            : 24 /* OrientationFlag.VERTICAL */;
    }
    ngOnChanges({ items }) {
        if (items && !items.currentValue) {
            this.items = [];
        }
    }
    focus() {
        this._viewerElRef.nativeElement.focus();
    }
    next() {
        this._viewerRef.selectByDelta(1);
    }
    prev() {
        this._viewerRef.selectByDelta(-1);
    }
    select(index) {
        this._viewerRef.select(index);
        this._thumbsRef?.select(index);
        this._selectInternal(index);
    }
    slideThumbs(direction) {
        this._thumbsRef?.slide(direction);
    }
    _onThumbClick(event) {
        this._viewerRef.select(event.index);
        this.thumbClick.emit(event);
        this._selectInternal(event.index);
    }
    _selectInternal(index) {
        this.selectedIndex = index;
        this.selection.emit(this.items[index]);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: GalleryComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.8", type: GalleryComponent, isStandalone: true, selector: "gallery", inputs: { items: "items", selectedIndex: "selectedIndex", aria: "aria", arrows: "arrows", descriptions: "descriptions", errorText: "errorText", showErrors: "showErrors", mouseGestures: "mouseGestures", touchGestures: "touchGestures", clip: "clip", counter: "counter", counterOrientation: "counterOrientation", loading: "loading", loop: "loop", objectFit: "objectFit", isRtl: "isRtl", visibleItems: "visibleItems", moveByItems: "moveByItems", itemTemplate: "itemTemplate", errorTemplate: "errorTemplate", arrowTemplate: "arrowTemplate", contentTemplate: "contentTemplate", thumbs: "thumbs", thumbsAutoScroll: "thumbsAutoScroll", thumbsOrientation: "thumbsOrientation", thumbsArrows: "thumbsArrows", thumbsArrowSlideByLength: "thumbsArrowSlideByLength", thumbsScrollBehavior: "thumbsScrollBehavior", thumbTemplate: "thumbTemplate", thumbsArrowTemplate: "thumbsArrowTemplate", thumbErrorTemplate: "thumbErrorTemplate" }, outputs: { itemClick: "itemClick", thumbClick: "thumbClick", thumbHover: "thumbHover", descriptionClick: "descriptionClick", selection: "selection" }, host: { listeners: { "keydown.arrowright": "next()", "keydown.arrowleft": "prev()" }, properties: { "class.rtl": "this.isRtl", "class.gallery--column": "this._galleryColumn" } }, viewQueries: [{ propertyName: "_viewerRef", first: true, predicate: ViewerComponent, descendants: true }, { propertyName: "_thumbsRef", first: true, predicate: ThumbsComponent, descendants: true }, { propertyName: "_viewerElRef", first: true, predicate: ViewerComponent, descendants: true, read: ElementRef }], usesOnChanges: true, ngImport: i0, template: "<span *ngIf=\"aria?.galleryLabel\" class=\"sr-only\" tabindex=\"0\">\n  {{ aria.galleryLabel }}\n</span>\n\n<thumbs\n  *ngIf=\"thumbs\"\n  [items]=\"items\"\n  [selectedIndex]=\"selectedIndex\"\n  [orientation]=\"thumbsOrientation\"\n  [arrows]=\"thumbsArrows\"\n  [arrowSlideByLength]=\"thumbsArrowSlideByLength\"\n  [autoScroll]=\"thumbsAutoScroll\"\n  [scrollBehavior]=\"thumbsScrollBehavior\"\n  [thumbTemplate]=\"thumbTemplate\"\n  [arrowTemplate]=\"thumbsArrowTemplate\"\n  [errorTemplate]=\"thumbErrorTemplate\"\n  [aria]=\"aria\"\n  [isRtl]=\"isRtl\"\n  (thumbClick)=\"_onThumbClick($event)\"\n  (thumbHover)=\"thumbHover.emit($event)\"\n></thumbs>\n\n<viewer\n  [items]=\"items\"\n  [selectedIndex]=\"+selectedIndex\"\n  [arrows]=\"arrows\"\n  [descriptions]=\"descriptions\"\n  [errorText]=\"errorText\"\n  [showErrors]=\"showErrors\"\n  [mouseGestures]=\"mouseGestures\"\n  [touchGestures]=\"touchGestures\"\n  [clip]=\"clip\"\n  [counter]=\"counter\"\n  [counterOrientation]=\"counterOrientation\"\n  [visibleItems]=\"visibleItems\"\n  [moveByItems]=\"moveByItems\"\n  [objectFit]=\"objectFit\"\n  [loading]=\"loading\"\n  [itemTemplate]=\"itemTemplate\"\n  [errorTemplate]=\"errorTemplate\"\n  [contentTemplate]=\"contentTemplate\"\n  [loop]=\"loop\"\n  [thumbsOrientation]=\"_thumbsOrientationFlag\"\n  [arrowTemplate]=\"arrowTemplate\"\n  [aria]=\"aria\"\n  [isRtl]=\"isRtl\"\n  (itemClick)=\"itemClick.emit($event)\"\n  (descriptionClick)=\"descriptionClick.emit($event)\"\n  (selection)=\"_selectInternal($event); _thumbsRef?.select($event)\"\n>\n</viewer>\n", styles: [":host{display:flex;height:600px;width:500px;outline:0;position:relative}:host.gallery--column{flex-direction:column}:host.rtl{direction:ltr}:host.rtl viewer,:host.rtl thumbs{direction:rtl}:host::ng-deep{font-family:Helvetica Neue,Helvetica,Arial,sans-serif}:host::ng-deep button{border:none}:host::ng-deep ul{list-style-type:none;margin:0;padding:0}:host::ng-deep .sr-only{position:absolute!important;clip:rect(1px,1px,1px,1px);top:auto;left:-9999px;width:1px;height:1px;overflow:hidden}\n"], dependencies: [{ kind: "ngmodule", type: CommonModule }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ThumbsComponent, selector: "thumbs", inputs: ["items", "selectedIndex", "aria", "orientation", "arrows", "arrowSlideByLength", "autoScroll", "thumbTemplate", "arrowTemplate", "errorTemplate", "scrollBehavior", "isRtl"], outputs: ["thumbClick", "thumbHover"] }, { kind: "component", type: ViewerComponent, selector: "viewer", inputs: ["items", "selectedIndex", "arrows", "descriptions", "errorText", "showErrors", "mouseGestures", "touchGestures", "counter", "counterOrientation", "loading", "objectFit", "itemTemplate", "errorTemplate", "arrowTemplate", "contentTemplate", "thumbsOrientation", "aria", "loop", "visibleItems", "moveByItems", "clip", "isRtl"], outputs: ["itemClick", "descriptionClick", "selection"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.8", ngImport: i0, type: GalleryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'gallery', changeDetection: ChangeDetectionStrategy.OnPush, standalone: true, imports: [CommonModule, ThumbsComponent, ViewerComponent], template: "<span *ngIf=\"aria?.galleryLabel\" class=\"sr-only\" tabindex=\"0\">\n  {{ aria.galleryLabel }}\n</span>\n\n<thumbs\n  *ngIf=\"thumbs\"\n  [items]=\"items\"\n  [selectedIndex]=\"selectedIndex\"\n  [orientation]=\"thumbsOrientation\"\n  [arrows]=\"thumbsArrows\"\n  [arrowSlideByLength]=\"thumbsArrowSlideByLength\"\n  [autoScroll]=\"thumbsAutoScroll\"\n  [scrollBehavior]=\"thumbsScrollBehavior\"\n  [thumbTemplate]=\"thumbTemplate\"\n  [arrowTemplate]=\"thumbsArrowTemplate\"\n  [errorTemplate]=\"thumbErrorTemplate\"\n  [aria]=\"aria\"\n  [isRtl]=\"isRtl\"\n  (thumbClick)=\"_onThumbClick($event)\"\n  (thumbHover)=\"thumbHover.emit($event)\"\n></thumbs>\n\n<viewer\n  [items]=\"items\"\n  [selectedIndex]=\"+selectedIndex\"\n  [arrows]=\"arrows\"\n  [descriptions]=\"descriptions\"\n  [errorText]=\"errorText\"\n  [showErrors]=\"showErrors\"\n  [mouseGestures]=\"mouseGestures\"\n  [touchGestures]=\"touchGestures\"\n  [clip]=\"clip\"\n  [counter]=\"counter\"\n  [counterOrientation]=\"counterOrientation\"\n  [visibleItems]=\"visibleItems\"\n  [moveByItems]=\"moveByItems\"\n  [objectFit]=\"objectFit\"\n  [loading]=\"loading\"\n  [itemTemplate]=\"itemTemplate\"\n  [errorTemplate]=\"errorTemplate\"\n  [contentTemplate]=\"contentTemplate\"\n  [loop]=\"loop\"\n  [thumbsOrientation]=\"_thumbsOrientationFlag\"\n  [arrowTemplate]=\"arrowTemplate\"\n  [aria]=\"aria\"\n  [isRtl]=\"isRtl\"\n  (itemClick)=\"itemClick.emit($event)\"\n  (descriptionClick)=\"descriptionClick.emit($event)\"\n  (selection)=\"_selectInternal($event); _thumbsRef?.select($event)\"\n>\n</viewer>\n", styles: [":host{display:flex;height:600px;width:500px;outline:0;position:relative}:host.gallery--column{flex-direction:column}:host.rtl{direction:ltr}:host.rtl viewer,:host.rtl thumbs{direction:rtl}:host::ng-deep{font-family:Helvetica Neue,Helvetica,Arial,sans-serif}:host::ng-deep button{border:none}:host::ng-deep ul{list-style-type:none;margin:0;padding:0}:host::ng-deep .sr-only{position:absolute!important;clip:rect(1px,1px,1px,1px);top:auto;left:-9999px;width:1px;height:1px;overflow:hidden}\n"] }]
        }], propDecorators: { items: [{
                type: Input
            }], selectedIndex: [{
                type: Input
            }], aria: [{
                type: Input
            }], arrows: [{
                type: Input
            }], descriptions: [{
                type: Input
            }], errorText: [{
                type: Input
            }], showErrors: [{
                type: Input
            }], mouseGestures: [{
                type: Input
            }], touchGestures: [{
                type: Input
            }], clip: [{
                type: Input
            }], counter: [{
                type: Input
            }], counterOrientation: [{
                type: Input
            }], loading: [{
                type: Input
            }], loop: [{
                type: Input
            }], objectFit: [{
                type: Input
            }], isRtl: [{
                type: HostBinding,
                args: ['class.rtl']
            }, {
                type: Input
            }], visibleItems: [{
                type: Input
            }], moveByItems: [{
                type: Input
            }], itemTemplate: [{
                type: Input
            }], errorTemplate: [{
                type: Input
            }], arrowTemplate: [{
                type: Input
            }], contentTemplate: [{
                type: Input
            }], thumbs: [{
                type: Input
            }], thumbsAutoScroll: [{
                type: Input
            }], thumbsOrientation: [{
                type: Input
            }], thumbsArrows: [{
                type: Input
            }], thumbsArrowSlideByLength: [{
                type: Input
            }], thumbsScrollBehavior: [{
                type: Input
            }], thumbTemplate: [{
                type: Input
            }], thumbsArrowTemplate: [{
                type: Input
            }], thumbErrorTemplate: [{
                type: Input
            }], itemClick: [{
                type: Output
            }], thumbClick: [{
                type: Output
            }], thumbHover: [{
                type: Output
            }], descriptionClick: [{
                type: Output
            }], selection: [{
                type: Output
            }], _viewerRef: [{
                type: ViewChild,
                args: [ViewerComponent]
            }], _thumbsRef: [{
                type: ViewChild,
                args: [ThumbsComponent]
            }], _viewerElRef: [{
                type: ViewChild,
                args: [ViewerComponent, { read: ElementRef }]
            }], _galleryColumn: [{
                type: HostBinding,
                args: ['class.gallery--column']
            }], next: [{
                type: HostListener,
                args: ['keydown.arrowright']
            }], prev: [{
                type: HostListener,
                args: ['keydown.arrowleft']
            }] } });

/*
 * Public API Surface of the gallery
 */

/**
 * Generated bundle index. Do not edit.
 */

export { GalleryComponent, SUPPORT, UA, isBrowser, orientations };
//# sourceMappingURL=daelmaak-ngx-gallery.mjs.map
